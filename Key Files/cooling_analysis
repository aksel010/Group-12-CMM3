import numpy as np
from scipy.optimize import fsolve
import sympy as sp
from pathlib import Path
from heptane_itpl import (
        calculate_h, 
        Cp_func, 
        rho_func, 
        mu_func,
        lambda_func # lambda_func (thermal conductivity) is also needed by calculate_h
    )

import numpy as np
from scipy.optimize import fsolve

def analyze_cooling_system(Q_main_L_min, T_avg_K=300, D_main=17e-03, n_branches=5, 
                          w_branch=30e-03, h_branch=2.75e-03, L_a=0.5, L_b=0.5, L_c=0.2):
    """
    Analyze parallel cooling system flow distribution and head loss for Group A
    
    Parameters:
    -----------
    Q_main_L_min : float
        Main pipe flow rate in L/min
    T_avg_K : float, optional
        Average coolant temperature in Kelvin (default: 300)
    D_main : float, optional  
        Main pipe diameter in meters (default: 17e-03)
    n_branches : int, optional
        Number of parallel branches (default: 5)
    w_branch : float, optional
        Branch width in meters (default: 30e-03)
    h_branch : float, optional
        Branch height in meters (default: 2.75e-03)
    L_a : float, optional
        Main pipe segment length in meters (default: 0.5)
    L_b : float, optional
        Branch pipe length in meters (default: 0.5)
    L_c : float, optional
        Additional main pipe length in meters (default: 0.2)
    
    Returns:
    --------
    dict
        Dictionary containing all analysis results
    """
    
    class SystemParams:
        def __init__(self):
            self.n = n_branches
            self.D = D_main
            self.w_branch = w_branch
            self.h_branch = h_branch
            self.L_a = L_a
            self.L_b = L_b
            self.L_c = L_c
            self.g = 9.81
            
            # Calculate areas
            self.S_a = np.pi * (self.D/2)**2
            self.S_b = self.w_branch * self.h_branch
            self.d_H = 2 * self.w_branch * self.h_branch / (self.w_branch + self.h_branch)

    def calculate_branch_head_loss(Q, params, ν):
        """Calculate friction head loss for each branch according to Equation 30"""
        n = len(Q)
        H_branch = np.zeros(n)
        
        for i in range(n):
            main_pipe_loss = 0
            for j in range(i + 1):
                sum_Q_m = np.sum(Q[j:])
                term = (32 * ν * params.L_a / (params.D**2 * params.g)) * (sum_Q_m / params.S_a)
                main_pipe_loss += term
            
            main_pipe_loss *= 2
            
            branch_pipe_loss = (32 * ν * params.L_b / 
                               (params.d_H**2 * params.g)) * (Q[i] / params.S_b)
            
            H_branch[i] = main_pipe_loss + branch_pipe_loss
        
        return H_branch

    def calculate_local_losses(Q, params, ν):
        """Calculate local head losses according to Equations 19-26"""
        n = len(Q)
        H_local = np.zeros(n)
        ξ_bend = 0.2  # Estimated bend loss factor
        
        for i in range(n):
            V_main_in = np.sum(Q[i:]) / params.S_a
            V_branch = Q[i] / params.S_b
            
            # Separate flow loss (1-3)
            ξ_1_3 = 0.5 * (V_branch / V_main_in)**2 + 1
            # Convergence flow loss (3-1)  
            ξ_3_1 = (V_branch / V_main_in)**2 - (V_branch / V_main_in)**2 + 0.5 * (1 - V_branch / V_main_in)
            
            # Bend losses (24 bends per branch)
            H_bend = 24 * (ξ_bend / (2 * params.g)) * V_branch**2
            
            H_local[i] = (ξ_1_3 / (2 * params.g)) * V_main_in**2 + \
                         (ξ_3_1 / (2 * params.g)) * V_main_in**2 + \
                         H_bend
        
        return H_local

    def calculate_total_group_A_head_loss(Q_individual, params, ν):
        """Calculate TOTAL head loss for entire Group A"""
        n = len(Q_individual)
        
        H_branch_friction = calculate_branch_head_loss(Q_individual, params, ν)
        H_branch_local = calculate_local_losses(Q_individual, params, ν)
        
        # Main pipe losses (inlet and outlet segments)
        Q_total = np.sum(Q_individual)
        V_main = Q_total / params.S_a
        Re_main = V_main * params.D / ν
        λ_main = 64 / Re_main if Re_main < 2300 else 0.316 / Re_main**0.25
        
        H_main_friction = 2 * (λ_main * (params.L_c / params.D) * (V_main**2 / (2 * params.g)))
        
        H_common_branch = H_branch_friction[0] + H_branch_local[0]  # All branches equal
        H_total_Group_A = H_common_branch + H_main_friction
        
        return H_total_Group_A, H_branch_friction, H_branch_local, H_main_friction

    def solve_flow_distribution(Q_main, params, ν):
        """Solve for individual branch flows Qi"""
        def equations(Q_individual):
            Q = Q_individual[:-1]
            H_ref = Q_individual[-1]
            
            H_friction = calculate_branch_head_loss(Q, params, ν)
            H_local = calculate_local_losses(Q, params, ν)
            H_total = H_friction + H_local
            
            eqs = []
            for i in range(params.n):
                eqs.append(H_total[i] - H_ref)
            eqs.append(np.sum(Q) - Q_main)
            
            return eqs
        
        Q_initial_guess = np.ones(params.n + 1)
        Q_initial_guess[:-1] = Q_main / params.n
        Q_initial_guess[-1] = 1.0
        
        solution = fsolve(equations, Q_initial_guess)
        Q_individual = solution[:-1]
        H_common_branch = solution[-1]
        
        return Q_individual, H_common_branch

    # Main analysis execution
    params = SystemParams()
    Q_main = Q_main_L_min / 60000  # Convert to m³/s
    
    # Calculate fluid properties
    μ = mu_func(T_avg_K)
    ρ = rho_func(T_avg_K)
    ν = μ / ρ
    
    # Solve for branch flows
    Q_individual, H_common_branch = solve_flow_distribution(Q_main, params, ν)
    
    # Calculate total Group A head loss
    H_total_Group_A, H_branch_friction, H_branch_local, H_main_friction = calculate_total_group_A_head_loss(
        Q_individual, params, ν)
    
    # Calculate bias rate β
    β = (np.max(Q_individual) - np.min(Q_individual)) / np.min(Q_individual)
    
    # Calculate cross-sectional area ratio δ
    δ = params.S_a / (params.n * params.S_b)
    
    # Prepare results
    results = {
        'input_parameters': {
            'Q_main_L_min': Q_main_L_min,
            'T_avg_K': T_avg_K,
            'D_main': D_main,
            'n_branches': n_branches,
            'cross_section_ratio_δ': δ
        },
        'flow_distribution': {
            'branch_flows_L_min': [q * 60000 for q in Q_individual],
            'total_flow_verification_L_min': np.sum(Q_individual) * 60000,
            'bias_rate_β_percent': β * 100
        },
        'head_loss_analysis': {
            'common_branch_head_loss_m': H_common_branch,
            'branch_friction_loss_m': H_branch_friction[0],
            'branch_local_loss_m': H_branch_local[0],
            'main_pipe_loss_m': H_main_friction,
            'total_group_A_head_loss_m': H_total_Group_A
        },
        'validation': {
            'max_temperature_difference_estimate_C': β * 100 * 0.1,  # Empirical relationship
            'flow_uniformity_rating': 'Excellent' if β * 100 < 10 else 
                                    'Good' if β * 100 < 20 else 
                                    'Fair' if β * 100 < 30 else 'Poor'
        }
    }
    
    return results

# Example usage when run directly
if __name__ == "__main__":
    # Example call
    results = analyze_cooling_system(
        Q_main_L_min=5.0,
        T_avg_K=300,
        D_main=17e-03
    )
    
    # Print results
    print("COOLING SYSTEM ANALYSIS RESULTS")
    print("=" * 50)
    print(f"Main pipe flow: {results['input_parameters']['Q_main_L_min']} L/min")
    print(f"Cross-section ratio δ: {results['input_parameters']['cross_section_ratio_δ']:.3f}")
    print(f"Coolant temperature: {results['input_parameters']['T_avg_K']} K")
    
    print("\nFLOW DISTRIBUTION:")
    for i, flow in enumerate(results['flow_distribution']['branch_flows_L_min'], 1):
        print(f"  Branch {i}: {flow:.4f} L/min")
    print(f"Total flow verification: {results['flow_distribution']['total_flow_verification_L_min']:.4f} L/min")
    print(f"Bias rate β: {results['flow_distribution']['bias_rate_β_percent']:.2f}%")
    
    print("\nHEAD LOSS ANALYSIS:")
    print(f"  Common branch head loss: {results['head_loss_analysis']['common_branch_head_loss_m']:.6f} m")
    print(f"  Branch friction loss: {results['head_loss_analysis']['branch_friction_loss_m']:.6f} m")
    print(f"  Branch local loss: {results['head_loss_analysis']['branch_local_loss_m']:.6f} m")
    print(f"  Main pipe loss: {results['head_loss_analysis']['main_pipe_loss_m']:.6f} m")
    print(f"  TOTAL GROUP A HEAD LOSS: {results['head_loss_analysis']['total_group_A_head_loss_m']:.6f} m")
    
    print(f"\nVALIDATION:")
    print(f"  Flow uniformity: {results['validation']['flow_uniformity_rating']}")
    print(f"  Estimated max ΔT: {results['validation']['max_temperature_difference_estimate_C']:.2f}°C")